Blueprint
1.Create actor;
2.Select in outline and Blueprint/Create in detail,save to content;
3.Add blueprint from content into level;
4.Add node and connection in blueprint editor;
modify in level editor will only apply on blueprint instance;whereas modify in blueprint editor will apply for all blueprint self;

Movable
transform->mobility

Collision
collision presets in detail collision can prefer which type been process

EventHit
hit events

EventTick
update every frame

AddTimeline
could apply time line animation to value,just link Update to Input of Set node and animated value to value of Set node

PlaySound2D & PlaySoundatLocation
play sound

SpawnEmitteratLocation
spawn particles

SetTimerbyEvent,SetTimerbyFunctionName
perform an action after timer expired,can loop

Self node
GetReferenceToSelf

Branch node
break down workflow to two(true or false) depends on a boolean value

GetWorldDeltaSeconds
return time interval between frames

Transform
StaticMeshComponent->GetWorldTransform->BreakTransform

Custom blueprint event
register event,fire event,define class and function in c++
response event in blueprint

/** Activate Fancy New Project-Specific System Created in C++ ! */
UFUNCTION(BlueprintCallable, Category="SunShine")
void ActivateSunShine();

AI
4 components:
  1.NaveMeshBoundsVolume,from volume for traverse,P key to see
  2.BehaviorTree,AI driver create from content window
  3.AIController,connect behavior tree and character,can add components to extend ability,also create from content window and blueprint class
  4.BlackBoard,contains all AI data for behavior tree
bind AIController to character
  character must derived from APawn,connect from blueprint editor/Detail/Pawn/AIControllerClass
navigation behavior
  1.setup patrol points,create/AllClass/TargetPoint
  2.add collision component to TargetPoints
  3.create blackboard key,in blackboard editor create key with object type
  4.initialize patrol point for character,in character’s blueprint, use EventBeginPlay to trigger SetValueasObject which use self’s GetBlackBoard, BlackBoard’s patrol point name and current patrol point as inputs
  5.change patrol point by EventActorBeginOverlap

chase
  1.add PawnSensing component to AI Controller and set sight and angle
  2.add PlayerActor to Blackboard
  3.add OnSeePawn event into AI Controller,cast to Player and setValueasObject to Blackboard
  4.add a sequence with Blackboard decorator,select PlayerActor as key and OnResultChange as NotifyObserver,Lower Priority as Observer aborts
  5.add MoveTo as final task

behaviortree node
Selector,run children from left to right but stop when first succeeded;
Sequence,run all children from left to right

Networks

1.http
1)Add dependency inside project’s Build.cs
PrivateDependencyModuleNames.AddRange(new string[] {"HTTP"}); 
PrivateIncludePathModuleNames.AddRange(new string[] {"HTTP"});
2)Include header from reference places
#include "Http.h"
3)Build request and process
TSharedRef<IHttpRequest> HttpRequest = FHttpModule::Get().CreateRequest();
HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
HttpRequest->SetURL(TEXT("http://localhost/mywebpage.php"));
HttpRequest->SetVerb(TEXT("POST"));
HttpRequest->SetContentAsString(JsonStr);
HttpRequest->OnProcessRequestComplete().BindUObject(this, &ASUMiniGameMode::HttpCompleteCallback);
HttpRequest->ProcessRequest();
4)The callback
void ASUMiniGameMode::HttpCompleteCallback(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful){
     FString MessageBody = "";
     // If HTTP fails client-side, this will still be called but with a NULL shared pointer!
     if (!Response.IsValid())
          MessageBody = "{\"success\":\"Error: Unable to process HTTP Request!\"}";
     else if (EHttpResponseCodes::IsOk(Response->GetResponseCode()))
          MessageBody = Response->GetContentAsString();
     else
          MessageBody = FString::Printf(TEXT("{\"success\":\"HTTP Error: %d\"}"), Response->GetResponseCode());
}

2.socket
1)Add dependency inside project’s Build.cs
PublicDependencyModuleNames.AddRange(new string[]{"Sockets"});
2)Creating the Socket
FSocket* Socket = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateSocket(NAME_Stream, TEXT("default"), false);
3)Preparing the Address
FString address = TEXT("127.0.0.1");
int32 port = 19834;
FIPv4Address ip;
FIPv4Address::Parse(address, ip);
TSharedRef addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();
addr->SetIp(ip.GetValue());
addr->SetPort(port);
4)Connecting
bool connected = Socket->Connect(*addr);
5)Sending a Message
FString serialized = TEXT("loadPlayer|1");
TCHAR *serializedChar = serialized.GetCharArray().GetData();
int32 size = FCString::Strlen(serializedChar);
int32 sent = 0;
bool successful = Socket->Send((uint8*)TCHAR_TO_UTF8(serializedChar), size, sent);
6)As far as reading data back from your socket server the key is in the functions HasPendingData and Recv of the FSocket class.

3.websocket

Unreal network
on Character or Pawn?
client->rpc->server
server->rpc & variable replication->client
GameState,PlayerState:s&c
GameMode:server only
client,replicates property of Actor
server spawn actor->replicate to spawn in client
client spawn actor-local only

Link custom library
1.build with x64,/MD;
2.create ThirdParty/keye then copy headers and libraries into Includes and Libraries subpath;
3.*.build.cs
	public class panda : ModuleRules
	{
	    public panda(TargetInfo Target){
		LoadThirdParty(Target);
	    }

	    string ThirdPartyPath
	    {
	        get { return Path.GetFullPath(Path.Combine(ModuleDirectory, "../../ThirdParty/keye")); }
	    }

	    public bool LoadThirdParty(TargetInfo Target)
	    {
		bool isLibrarySupported = false;

		if ((Target.Platform == UnrealTargetPlatform.Win64) || (Target.Platform == UnrealTargetPlatform.Win32))
		{
		    isLibrarySupported = true;

		    string PlatformString = (Target.Platform == UnrealTargetPlatform.Win64) ? "Win64" : "Win32";
		    string LibraryPath = Path.Combine(ThirdPartyPath, "lib", PlatformString);

		    PublicAdditionalLibraries.Add(Path.Combine(LibraryPath, "keye.lib"));

		    PublicDelayLoadDLLs.Add("keye.dll");
		    RuntimeDependencies.Add(new RuntimeDependency(Path.Combine(LibraryPath, "keye.dll")));
		}
		else if (Target.Platform == UnrealTargetPlatform.Mac)
		{
		    isLibrarySupported = true;

		    string PlatformString = "Mac";
		    string LibraryPath = Path.Combine(ThirdPartyPath, "lib", PlatformString);
		    PublicAdditionalLibraries.Add(Path.Combine(LibraryPath, "keye.dylib"));
		}
		else if (Target.Platform == UnrealTargetPlatform.Linux)
		{
		    isLibrarySupported = true;

		    string PlatformString = "Linux";
		    string LibraryPath = Path.Combine(ThirdPartyPath, "lib", PlatformString);
		    PublicAdditionalLibraries.Add(Path.Combine(LibraryPath, "libkeye.so"));
		}

		if (isLibrarySupported)
		    PublicIncludePaths.Add(ThirdPartyPath);

		return isLibrarySupported;
	    }
	}
4.copy keye.dll to bin and run;